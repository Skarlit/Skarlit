<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>Canvas</title>
    <link rel="stylesheet" type="text/css" href="../../stylesheets/thirdparty/obsidian.css" media="screen">
    <script src="../../javascripts/thirdparty/hightlight.min.js"></script>
    <script src="../../javascripts/jquery-1.11.3.min.js"></script>
    <script src="util/mv.js"></script>
    <script src="util/initShaders.js"></script>
    <script src="util/webgl-utils.js"></script>
    <script src="../../javascripts/code.js"></script>
    <style>

    </style>
</head>
<body>
<button id="undo" disabled>Undo</button>
<button id="redo" disabled>Redo</button>
<canvas id="canvas">

</canvas>
<div id="code">


</div>
<script id="vs" type="shader">
//uniform float color;
attribute vec2 position;
void main () {
  gl_Position = vec4(position, 0.0, 1.0);
}
</script>
<script id="fs" type="shader">
precision mediump float;
void main () {
  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
}
</script>
<script id="main">
    // No deep copy of data, use primitive type only!
    function List() {
        this.head = null;
        this.cursor = this.head;
    };

    List.prototype.forEach = function(filter) {
        var iterator = this.head;
        while(iterator != this.cursor) {
            filter(iterator);
            iterator = iterator.next;
        }
        filter(this.cursor);
    };

    List.prototype.add = function(data) {
        if (!this.head) {
            // first time initalization
            this.head = new ListNode(0);
            this.cursor = this.head;
            return;
        }
        if (this.cursor.next) {  // diverge path
            // remove original path
            this.cursor.next.prev = null;
        }
        this.cursor.next = new ListNode(this.cursor.data);
        this.cursor.next.prev = this.cursor;
        this.cursor = this.cursor.next;
    };

    function ListNode (data) {
        this.next = null;
        this.prev = null;
        this.data = data;
    };


    window.onload = function() {
        var MouseStat = {
            down: false,
            x: 0,
            y: 0,
            trails: [],
            segments: new List()
        };

        var viewPortWidth = 800;
        var viewPortHeight = 600;

        var undoBtn = document.getElementById('undo');
        var redoBtn = document.getElementById('redo');
        var canvas = document.getElementById('canvas');
        canvas.width = viewPortWidth;
        canvas.height = viewPortHeight;
        var $canvas = $(canvas);
        var canvasOffset = $canvas.offset();
        function normalize(domX, domY) {
            return vec2(
                2 * (domX - canvasOffset.left)/viewPortWidth - 1,
                1 - 2 * (domY - canvasOffset.top)/viewPortHeight
            );
        }
        canvas.addEventListener('mousedown', function(e) {
            MouseStat.down = true;
            // Copy the last position in segments and add to segments
            MouseStat.segments.add();
            MouseStat.trails[MouseStat.segments.cursor.data] = normalize(e.clientX, e.clientY);
        });
        canvas.addEventListener('mouseup', function() {
            MouseStat.down = false;
            redoBtn.disabled =!( MouseStat.segments.cursor.next);
            undoBtn.disabled =!( MouseStat.segments.cursor.prev);
        });
        canvas.addEventListener('mousemove', function(e) {
            if (MouseStat.down) {
                MouseStat.segments.cursor.data++;
                MouseStat.trails[MouseStat.segments.cursor.data] = normalize(e.clientX, e.clientY);
                gl.bufferData(gl.ARRAY_BUFFER, flatten(MouseStat.trails), gl.STATIC_DRAW);
                draw();
            }
        });

        function draw() {
            gl.clear(gl.COLOR_BUFFER_BIT);
            MouseStat.segments.forEach(function(iterator) {
                if(iterator.next) {
                    gl.drawArrays(gl.LINE_STRIP, iterator.data, iterator.next.data - iterator.data);
                }
            });
        }

        undoBtn.addEventListener('click', function() {
            if (MouseStat.segments.cursor.prev) {
                MouseStat.segments.cursor = MouseStat.segments.cursor.prev;
                redoBtn.disabled = false;
                draw();
            } else {
                this.disabled = true;
            }
        });

        redoBtn.addEventListener('click', function() {
            if (MouseStat.segments.cursor.next) {
                MouseStat.segments.cursor = MouseStat.segments.cursor.next;
                undoBtn.disabled = false;
                draw();
            } else {
                this.disabled = true;
            }
        });

        // Init GL
        gl = WebGLUtils.setupWebGL( canvas );
        if ( !gl ) { alert( "WebGL isn't available" ); }
        gl.viewport(0, 0, viewPortWidth, viewPortHeight);
        gl.clearColor( 0.0, 0.0, 0.0, 0.0 );
        var program = initShaders( gl, "vs", "fs" );
        gl.useProgram( program );
        program.color = gl.getUniformLocation(program, "color");
        var bufferId = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, bufferId);
        program.position = gl.getAttribLocation(program, "position");
        gl.vertexAttribPointer( program.position, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray( program.position);
        gl.lineWidth(10);

        // Show code;
        Code.render(document.getElementById('code'),
                document.getElementById('vs').textContent, 'c++');
        Code.render(document.getElementById('code'),
                document.getElementById('fs').textContent, 'c++');
        Code.render(document.getElementById('code'),
                document.getElementById('main').textContent, 'js');
        $('pre code').each(function(i, block) {
            hljs.highlightBlock(block);
        });
    }


</script>
</body>
</html>